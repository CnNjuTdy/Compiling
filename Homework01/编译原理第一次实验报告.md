# 编译原理第一次实验报告

[TOC]

## 概述

​	这是编译原理的第一次实验报告

​	基本部分是第一部分:基于C语言子集的词法分析程序。这部分选取了C语言的一个子集给出了词法分析程序，对**给定的一段C语言代码(元素均在此子集中)**，输出是**该段代码的token序列**，以便后面的文法分析使用。

​	扩展部分是第二部分:LEX的部分实现。这部分对**给定的一个正则表达式**，**输出了其DFA的转化表**，由于时间所限，没有实现词法分析程序的生成程序。

## 实验环境

​	实验环境是**Windows10**系统，使用的语言是**Java**语言

## 第一部分: 基于C语言子集的词法分析程序

### 1. 假设与依赖

> 假设了实验使用的C语言子集
>
> 两个输入之间均用1个空格隔开

| Token     | 包含的输入                                    |
| --------- | ---------------------------------------- |
| **关键字**   | break case char const continue default do double else enum float for goto if int long main short signed sizoef static switch unsigned void |
| **操作符**   | ( ) [ ] . ! + ++ - -- * / % < <= > >= = == != & && \|\| , |
| **分隔符**   | ; { }                                    |
| **注释符**   | // /* */ “ ” ‘ ’                         |
| **忽略的字符** | \n \t blank                              |
| **整数**    | 所有整数(仅限正数)                               |
| **浮点数**   | 所有浮点数(仅限正数)                              |
| **标识符**   | 由数字,大小写英文字母和和下划线组成的并且由字母或下划线开头的任意字符串(不包含关键字) |

### 2. 思路与方法

> 本部分叙述了实验的正则表达式构造和主要思路

#### 2.1 正则表达式的构造

分成两个部分

**第一部分是有限长度，有限数目的token**

| Token   | 正则表达式                                    |
| ------- | ---------------------------------------- |
| **关键字** | break\|case\|char\|const\|continue\|default\|do\|double\|else\|enum\|float\|for\|goto\|if\|int\|long\|main\|short\|signed\|sizoef\|static\|switch\|unsigned\|void |
| **操作符** | (\|)\|[\|] .\|!\|+\|++\|-\|--\|*\|/\|%\|<\|<=\|>\|>=\|=\|==\|!=\|&\|&&\|\|\|\| , |
| **分隔符** | ;\|{\|}\|“\|”\|‘\|’                      |
| **注释符** | // \| /* \| */                           |

**第二个部分是无限长度，无限数目的token**

| Token   | 正则表达式                                   |
| ------- | --------------------------------------- |
| **整数**  | *digit*(*digit*)                        |
| **浮点数** | *digit* (*digit*)* . *digit* (*digit*)* |
| **标识符** | *letter*(*letter*\|*digit*)*            |

其中*digit*->0|1|2|3|4|5|6|7|8|9，letter->a|b|c…|z|A|B|C…|Z|_

#### 2.2 思路叙述

思路如下:


- 初始化常量
- 将文本的C程序代码读取成为**字节数组**
- 从左至右扫描**一遍**数组，利用**DFA**确定其归属的Token种类，并与原来的词法元素合并成为一个token，写入**输出字符串列表**中
- 将**输出字符串列表**中的字符串按照从前往后的顺序输出到文本

### 3. 自动状态机DFA构造描述

> 本部分详细叙述了从Regular Expression到DFA的过程

#### 3.1 RE->NFA

![NFA](img/NFA.png)

#### 3.2 NFA->DFA

![](img/DFA.png)

### 4. 数据结构描述

#### 4.1 状态枚举

```Java
    enum STATE{
    	DONE,//正常情况
    	INVAR,//标识符或者关键字
        INADD,INMINUS,//加减符号
        INLESS,INMORE,INEQUAL,//小于大于等于
        INEXCLAMATORY,//惊叹号
        INAND,INOR,//且 或
        INSOLIDUS,//斜线
        INDIGIT,//数字
        INDECIMALS,//小数
        ANNOTATION_ONE_LINE,ANNOTATION_MULTI_LINE,ANNOTATION_MULTI_LINE_ASTERISK,//各种注释
        SINGLE_QUOTE_MARK,DOUBLE_QUOTE_MARK//单引号双引号
    }
```

其中省略了很多符号例如`{ } %`d的状态，因为这些字符一旦被扫描到那么直接结束判定为某字符不用状态转换

#### 4.2 种类枚举以及map

```java
enum TOKEN{
        KEYWORDS,//关键字
        IDENTIFIER,//标识符
        OPERATOR,//操作符
        DELIMITER,//分隔符
        INT,//整数
        DOUBLE,//浮点数
        ANNOTATION//注释符
    }
private static void initMap() {
        map.put(TOKEN.KEYWORDS, "关键字");
        map.put(TOKEN.IDENTIFIER, "标识符");
        map.put(TOKEN.OPERATOR, "操作符");
        map.put(TOKEN.DELIMITER, "分隔符");
        map.put(TOKEN.INT, "整数");
        map.put(TOKEN.DOUBLE, "浮点数");
        map.put(TOKEN.ANNOTATION, "注释符");
    }
```

#### 4.2 关键词数组

```java
static String KEYWORDS[] = {"break", "case", "char", "const",
            "continue", "default", "do", "double", "else", "enum", "float", "for", "goto", "if",
            "long","main","short","signed","sizoef","static","switch","unsigned","void"};
```

### 5. 核心算法描述

核心算法扫描输入字符串，通过状态转换确定token种类，对应代码中的`void AnalyzeStart() throws Exception`方法

1. 读取下一个字节
2. 建立读入缓存，这个缓存中记录现在读入的一个词法单元
3. 如果是结束字节那么**结束循环**跳到6如果不是继续
4. 判断状态，如果是done状态跳到1否则继续
5. switch状态，例如如果是var，那么读取字符一直到不是letter为止，然后判断是不是关键字，之后清空读入缓存，向输出数组中写入内容，状态调整为done，循环至1
6. 结束

### 6. 测试情况

#### 6.1 测试用例输入

```c
void test() {
        int[] a;
        a[0]=(int)1.5;
        int b=2/1;
        //注释
        a++;
        if(a!=b)
            System.out.println("woshi zifuchuan");
        System.out.println(obj[1]);
    }
    
    
    void main{    
        /**
         * 这里是注释
         */
         test();
    }
```

#### 6.2 token序列输出

```tex
关键字		void
标识符		test
操作符		(
操作符		)
左大括号		{
标识符		int
操作符		[
操作符		]
标识符		a
分号		;
标识符		a
操作符		[
整数		0
操作符		]
操作符		=
操作符		(
标识符		int
操作符		)
浮点数		1.5
分号		;
标识符		int
标识符		b
操作符		=
整数		2
操作符		/
整数		1
分号		;
注释符		//
注释内容		注释
标识符		a
操作符		++
分号		;
关键字		if
操作符		(
标识符		a
操作符		!=
标识符		b
操作符		)
标识符		System
句号		.
标识符		out
句号		.
标识符		println
操作符		(
双引号		"
字符串		woshi zifuchuan
双引号		"
操作符		)
分号		;
标识符		System
句号		.
标识符		out
句号		.
标识符		println
操作符		(
标识符		obj
操作符		[
整数		1
操作符		]
操作符		)
分号		;
右大括号		}
关键字		void
关键字		main
左大括号		{
注释符		/*
注释内容		*
	 * 这里是注释
	
注释符		*/
标识符		test
操作符		(
操作符		)
分号		;
右大括号		}
```

## 第二部分:LEX部分实现

### 1. 假设与依赖

### 2. 思路与方法

### 3. 数据结构描述

### 4. 核心算法描述

### 5. 测试情况

## 困难与解决

## 总结与收获

## 参考文献

